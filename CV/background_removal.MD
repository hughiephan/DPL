## Step 1: Import libraries

```python
import requests
import numpy as np
import cv2
import matplotlib.pyplot as plt
from io import BytesIO
```

## Step 2: Download image

Frist, we download the desired image from Imgur using the HTTP requests. The image's content is downloaded as bytes and then stored in a `BytesIO` object. Then we use `Image.open()` from the Python Imaging Library (PIL) to read the image data as numpy array.

```python
url = 'https://i.imgur.com/RE1xBRe.png'
response = requests.get(url)
image_bytes = BytesIO(response.content)
image = np.array(Image.open(image_bytes))
```

![image](https://github.com/hughiephan/DPL/assets/16631121/357b2e56-8eb2-4b86-8e0c-28d811128afd)

## Step 3: Pre-process image

Edge detection uses image's intensity instead of full-range color image so we need to converts the input image from its original color space `RGB` to grayscale using the `cv2.cvtColor`. The image is converted to a single channel representing grayscale intensity. Then we apply Gaussian blur to the grayscale image using the `cv2.GaussianBlur()` to reduce image noise and smooth out details by convolving the image with a Gaussian kernel. In this case, the kernel size is set to (5, 5), indicating a 5x5 window, and the standard deviation is set to 0.

```python
gray_image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
smoothed_image = cv2.GaussianBlur(gray_image, (5, 5), 0)
```
![image](https://github.com/hughiephan/DPL/assets/16631121/ae2f90cc-2f81-4d8e-8c78-2197d5a6ad4c)

## Step 4: Mask

`cv2.Sobel` calculates the gradient of the image intensity in both the horizontal and vertical directions. Following this, the absolute value of the edges is computed using NumPy's `np.absolute`, ensuring all values are positive. Then, this absolute value is converted to an unsigned 8-bit integer type using `np.uint8`. Finally, a binary mask is generated by thresholding the absolute edges using the specified threshold value `50` . Pixels with values above the threshold are set to white `255` , indicating the presence of an edge, while pixels below the threshold are set to black `0`.

```python
threshold_value = 50
edges = cv2.Sobel(smoothed_image, cv2.CV_64F, 1, 1, ksize=5)
_, binary_mask = cv2.threshold(np.uint8(np.absolute(edges)), threshold_value, 255, cv2.THRESH_BINARY)
```
![image](https://github.com/hughiephan/DPL/assets/16631121/9d5e5f5b-fd6f-4f3a-bd2c-8b4707e80e5d)

## Step 5: Result
```python
foreground = cv2.bitwise_and(image, image, mask=binary_mask)
```

![image](https://github.com/hughiephan/DPL/assets/16631121/a6a29d17-b3ac-40eb-8b02-3b812d3275bc)

## Optional:
```python
plt.imshow(image)
plt.imshow(smoothed_image, cmap='gray')
plt.imshow(binary_mask, cmap='gray')
plt.imshow(foreground)
```
