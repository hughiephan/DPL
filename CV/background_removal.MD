# Background Removal with Edge Detection

![image](https://github.com/hughiephan/DPL/assets/16631121/4340639d-5e19-434b-92bc-6a19309186c6)

Edge is used directly for image editing. It allows users to selectively remove edges corresponding to unwanted features such as specularities, shadows, or distracting visual elements. After reconstructing the image from the remaining edges, the undesirable visual features have been removed. This tutorial will show how to use edges as a mask for background removal to preserve the foreground object through Sobel edge detection algorithms. Sobel can help highlight regions of significant intensity variation, representing edges of objects within the image. We will converts the edge image into a binary mask, where pixels representing edges are set to a specific value while others are suppressed, effectively isolates the edges of the foreground object. And finally we apply this binary mask to the original image using a bitwise AND operation to remove the background, leaving behind only the foreground object.

## Step 1: Import libraries

```python
import requests
import numpy as np
import cv2
import matplotlib.pyplot as plt
from io import BytesIO
from PIL import Image
```

## Step 2: Download image

First, we download the desired image from Imgur using the HTTP requests. The image's content is downloaded as bytes and then stored in a `BytesIO` object. Then we use `Image.open()` from the Python Imaging Library (PIL) to read the image data as numpy array.

```python
url = 'https://i.imgur.com/RE1xBRe.png'
response = requests.get(url)
image_bytes = BytesIO(response.content)
image = np.array(Image.open(image_bytes))
```

![image](https://github.com/hughiephan/DPL/assets/16631121/357b2e56-8eb2-4b86-8e0c-28d811128afd)

## Step 3: Pre-process image

Edge detection uses image's intensity instead of full-range color image so we need to converts the input image from its original color space `RGB` to grayscale using the `cv2.cvtColor`. The image is converted to a single channel representing grayscale intensity. Then we apply Gaussian blur to the grayscale image using the `cv2.GaussianBlur()` to reduce image noise and smooth out details by convolving the image with a Gaussian kernel. In this case, the kernel size is set to (5, 5), indicating a 5x5 window, and the standard deviation is set to 0.

```python
gray_image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
smoothed_image = cv2.GaussianBlur(gray_image, (5, 5), 0)
```
![image](https://github.com/hughiephan/DPL/assets/16631121/ae2f90cc-2f81-4d8e-8c78-2197d5a6ad4c)

## Step 4: Object mask

`cv2.Sobel` calculates the gradient of the image intensity in both the horizontal and vertical directions. `CV_64FC3` is colored image with 3 channels but we are processing simple grayscale image and has only 1 channel so we will use `CV_64FC1` or ``CV_64F`. With `CV_` is a prefix, `64` bit, and `F` is for float. `ksize=5` means that a 5x5 Sobel kernel will be used. With `1,1` indicate the First-Order derivative in x direction, and the First-Order derivative in the y direction.

```python
edges = cv2.Sobel(smoothed_image, cv2.CV_64F, 1, 1, ksize=5)
```

## Step 5: Binary Threshold

We choose Binary Thresholding mode with `cv2.THRESH_BINARY`. A binary mask is generated by thresholding the absolute edges using the specified threshold value `50` . Pixels with values above the threshold are set to white `255` , indicating the presence of an edge, while pixels below the threshold are set to black `0`. Simple thresholding is effective when the image has consistent lighting conditions and a clear foreground-background separation. However, when images contain varying lighting conditions or complex backgrounds, adaptive thresholding techniques are more suitable. Following this, the absolute value of the edges is computed using NumPy's `np.absolute`, ensuring all values are positive. Then, this absolute value is converted to an unsigned 8-bit integer type using `np.uint8`. 

![image](https://github.com/hughiephan/DPL/assets/16631121/339684cb-33a1-4d98-9190-d145bc6a4cae)

```python
threshold_value = 50
_, binary_mask = cv2.threshold(np.uint8(np.absolute(edges)), threshold_value, 255, cv2.THRESH_BINARY)
```

![image](https://github.com/hughiephan/DPL/assets/16631121/9d5e5f5b-fd6f-4f3a-bd2c-8b4707e80e5d)

## Step 6: Foreground object with Bitwise-And

Compares each bit of the first operand to the corresponding bit of the second operand. If both bits are 1, the corresponding result bit is set to 1. Otherwise, the corresponding result bit is set to 0

![image](https://github.com/hughiephan/DPL/assets/16631121/2702e4b5-8220-4617-9750-f62a8bfadbf6)

The bitwise operation `AND` is applied element-wise to the corresponding pixels of the two input images. 

![image](https://github.com/hughiephan/DPL/assets/16631121/213b65bf-ea8a-4bcb-a1a8-5ff15b10243f)

In this case, the input images are both the original image. The binary mask `binary_mask` acts as a filter, determining which pixels from the original image should be retained based on their corresponding values in the mask. Pixels in the original image where the corresponding pixel in the mask is white `non-zero` will be preserved, while pixels where the mask is back `zero` will be set to zero in the output image. This effectively isolates the foreground regions of the original image based on the edges detected in the previous step, producing a new image representing only the foreground objects. 

```python
foreground = cv2.bitwise_and(image, image, mask=binary_mask)
```

![image](https://github.com/hughiephan/DPL/assets/16631121/a6a29d17-b3ac-40eb-8b02-3b812d3275bc)

## Optional Commands
```python
plt.imshow(image)
plt.imshow(smoothed_image, cmap='gray')
plt.imshow(binary_mask, cmap='gray')
plt.imshow(foreground)
```

## Reference
- https://encord.com/blog/image-thresholding-image-processing
- https://omes-va.com/operadores-bitwise
- https://stackoverflow.com/questions/19248926/difference-of-opencv-mat-types
